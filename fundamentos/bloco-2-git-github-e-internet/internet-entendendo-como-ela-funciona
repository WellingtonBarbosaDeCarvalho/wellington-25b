Explicar de forma simples como a internet funciona;
Entender o modelo Cliente & Servidor e identificar suas partes;
Compreender como funcionam os protocolos HTTP e HTTPS;
Identificar quais os tipos de requisi√ß√£o podem ser feitos atrav√©s desses protocolos.
Explicar de forma simples como a internet funciona;
Entender o modelo Cliente & Servidor e identificar suas partes;
Compreender como funcionam os protocolos HTTP e HTTPS;
Identificar quais os tipos de requisi√ß√£o podem ser feitos atrav√©s desses protocolos.
Por que isso √© importante?
Como uma pessoa que ir√° desenvolver software para a internet, conhecer o seu funcionamento √© um requisito primordial.
√â importante ter uma no√ß√£o de como a rede da internet √© estruturada, pois quando voc√™ for pensar no design de uma aplica√ß√£o web, por exemplo, ter√° que considerar fatores como a lat√™ncia da rede, a geolocaliza√ß√£o dos servidores, a velocidade e/ou disponibilidade de conex√£o dos usu√°rios, enfim. üîÆ
Atualmente, a grande maioria das aplica√ß√µes web s√£o desenvolvidas usando o modelo Cliente & Servidor. Voc√™ precisa entender esse modelo para entender como o software que voc√™ ir√° desenvolver se encaixa nele. Voc√™ precisa, em suma, saber como os servidores funcionam, para quando for colocar um projeto "no ar", ou "em produ√ß√£o". üñ•

As pe√ßas que montam a Internet
Ao longo da sua carreira como desenvolvedor, voc√™ far√° p√°ginas incr√≠veis que estar√£o dispon√≠veis para usu√°rios do mundo todo na Internet. Mas voc√™ j√° se perguntou como esse processo acontece? Antes de prosseguir na leitura, reflita um pouco sobre como voc√™ acredita que as suas p√°ginas web funcionam!
O mundo Web √© t√£o presente no nosso dia a dia que esquecemos o qu√£o complexo ele √©. Conhec√™-lo ser√° fundamental quando voc√™ come√ßar a arquitetar o backend da sua aplica√ß√£o, e muito importante para que voc√™ desenvolva p√°ginas web que funcionem de fato.
Entender a Internet pode parecer intimidador pois h√° muitos termos espec√≠ficos que s√£o constantemente utilizados. Vamos come√ßar a desmistific√°-los fazendo aquilo que fazemos praticamente todos os dias ao abrir o nosso navegador: acesse www.google.com. O que est√° por tr√°s desse acesso? Vamos listar primeiro os conceitos b√°sicos para entend√™-lo:
Cliente: Firefox, Mozilla, Chrome... qual o navegador voc√™ utilizou para fazer a sua pesquisa? O termo t√©cnico para ele √© cliente. O cliente √© uma aplica√ß√£o que est√° conectada √† Internet. A sua principal fun√ß√£o √© receber a intera√ß√£o do usu√°rio e traduzi-la em uma requisi√ß√£o para outro computador chamado Servidor Web. Apesar de usarmos o navegador para acessar √† Internet, voc√™ pode pensar no seu computador como sendo o Cliente no modelo Cliente-Servidor. Todo computador tem um n√∫mero √∫nico, como o seu CPF, chamado endere√ßo IP. √â atrav√©s desse endere√ßo que computadores, celulares e tablets s√£o identificados.
Servidor: Como vimos no exemplo acima, nossa busca por www.google.com ser√° enviada para um Servidor. O Servidor √© um super computador conectado √† Internet. Ele tamb√©m tem o seu pr√≥prio endere√ßo IP, assim como o seu computador. O Servidor espera por requisi√ß√µes de outras m√°quinas (clientes). Diferente do seu computador, um Servidor tem um software espec√≠fico em execu√ß√£o que ir√° dizer como ele deve responder a uma requisi√ß√£o do seu navegador. A principal fun√ß√£o do Servidor √© armazenar, processar e entregar p√°ginas web para os Clientes. H√° diversos tipos de servidores, como Web Servers, Database Servers, File Servers, Application Servers. O servidor que usamos para fazer a busca por www.google.com √© um Web Server.
Endere√ßo IP: A sigla IP refere-se a Internet Protocol. O endere√ßo IP √© um identificador num√©rico para um dispositivo (computador, celular, tablet, impressora, roteador, servidor...) conectado √† rede TCP/IP. Todo dispositivo conectado √† Internet tem um endere√ßo IP √∫nico que ir√° identific√°-lo, e ser√° usado para comunicar com outros dispositivos. Os endere√ßos IP tem quatro campos de d√≠gitos separados por pontos (exemplo: 244.155.65.2). Esses n√∫meros s√£o chamados de endere√ßo l√≥gico. Para localizar um dispositivo conectado √† Internet o endere√ßo l√≥gico √© convertido em um endere√ßo f√≠sico por um software. Esse endere√ßo f√≠sico faz parte do seu hardware e √© conhecido por endere√ßo de controle de acesso √† m√≠dia (MAC address).
TCP/IP: De forma simples, o TCP/IP √© o principal protocolo de envio e recebimento de dados na internet. TCP significa Transmission Control Protocol (Protocolo de Controle de Transmiss√£o), em suma, o TCP ser√° respons√°vel por definir como diferentes aplica√ß√µes se comunicam na rede e tamb√©m em como os dados enviados ser√£o divididos em pacotes. E o IP, Internet Protocol (Protocolo de Internet), define como os dados divididos em pacotes devem ser enviados para chegar corretamente ao destinat√°rio. O TCP/IP √© a uni√£o dos protocolos TCP e IP, uma pilha de protocolos que √© dividida em quatro camadas: aplica√ß√£o, transporte, rede e interface. Cada uma dessas camadas tem uma responsabilidade espec√≠fica, mas todas s√£o conectadas entre si para garantir a seguran√ßa e a disponibilidade dos dados. Entenda mais a fundo
ISP: ISP ou Internet Service Provider √© o seu provedor de Internet. √â qualquer empresa que nos fornece acesso ao maravilhoso mundo Web. Sem os seus servi√ßos, n√£o conseguir√≠amos fazer a nossa busca por www.google.com pois n√£o estar√≠amos conectados √† Internet.
DNS: DNS ou Domain Name System √© um dispositivo com uma base de dados distribu√≠da que gerencia os nomes de servi√ßos, computadores ou qualquer dispositivo conectado √† Internet. Ele √© usado para relacionar o endere√ßo nominal (google.com) com o endere√ßo IP. Os servidores DNS s√£o respons√°veis por localizar e traduzir para n√∫meros (um endere√ßo IP) as buscas por sites que digitamos no navegador.
Port Number: O n√∫mero de porta √© um n√∫mero de 16 bits utilizado para identificar uma porta espec√≠fica no servidor, e est√° sempre associado ao endere√ßo IP. O Port number √© uma forma de identificar um processo espec√≠fico encaminhado para o servidor.
Host: O Host √© qualquer dispositivo conectado √† rede que pode transmitir ou receber pacotes IP, seja como cliente, servidor ou qualquer outro tipo de modelo, sendo que cada host tem um endere√ßo IP √∫nico. Dentre esses dispositivos temos: computadores, tablets, smarts TV, smartpphones, entre outros. Para o site que estamos buscando, www.google.com, o host √© o servidor web que hospeda a p√°gina na web. √â comum confundir o host com o servidor. Lembre-se que eles s√£o coisas diferentes! O Servidor √© um tipo de host - uma m√°quina espec√≠fica com endere√ßo IP. Por outro lado, o host pode ser tamb√©m uma organiza√ß√£o inteira que fornece um servi√ßo de hospedagem para manter in√∫meros servidores web.
HTTP: Hyper-text Transfer Protocol √© o protocolo utilizado para a comunica√ß√£o entre navegadores e servidores na Internet.
URL: O URL √© a sigla para Uniform Resource Locators e identifica um recurso web espec√≠fico. Podemos, como exemplo, mudar a nossa busca para https://www.google.com/travel/flights para pesquisar por pre√ßos de passagens a√©reas. O URL identifica o protocolo que ser√° utilizado para comunicarmos com o servidor (https), o nome do host (google.com) e o recurso que queremos acessar (travel/flights).
Depois responda ao quiz, lembrando que ele serve para fixa√ß√£o dos conte√∫dos e n√£o tem car√°ter avaliativo, n√£o se preocupe!



O modelo cliente-servidor e a estrutura de uma aplica√ß√£o web
Agora voc√™ vai entender como funciona uma aplica√ß√£o web, e como √© poss√≠vel torn√°-la escal√°vel. Para isso, voc√™ precisa conhecer um pouco mais sobre o modelo Cliente-Servidor e sobre a estrutura de uma p√°gina Web. At√© aqui voc√™ j√° aprendeu alguns conceitos b√°sicos sobre o mundo Web. Voc√™ j√° tem uma ideia de como o cliente (seu computador) interage com um servidor. O pr√≥ximo passo ser√° ir um pouco mais a fundo para entender como todas as partes que vimos se relacionam para nos permitir navegar na Internet.
O modelo cliente-servidor √© utilizado para descrever a forma com que um cliente (um computador conectado √† Web) e um servidor se comunicam na rede. Voc√™ pode visualizar essa ideia no diagrama simplificado abaixo:

Modelo Cliente-Servidor
No entanto, essa representa√ß√£o √© apenas um modelo. H√° outras partes envolvidas que s√£o importantes e que permitem com que voc√™ tenha acesso a esse conte√∫do que est√° estudando agora, por exemplo. Para isso, vamos entender como as pe√ßas desse quebra cabe√ßa se encaixam em uma aplica√ß√£o web.
Aplica√ß√µes web, como essa que voc√™ est√° usando em seus estudos aqui na Trybe, seguem uma estrutura b√°sica muito similar. Elas s√£o compostas por um cliente, um servidor e uma base de dados.
O cliente √© respons√°vel por interagir com o usu√°rio. Em uma aplica√ß√£o Web o cliente √© respons√°vel por definir a estrutura, a apar√™ncia e mecanismos para lidar com as intera√ß√µes do usu√°rio (como um click, ou um campo para preenchimento).
A estrutura da sua p√°gina √© definida por uma linguagem chamada HTML, que √© a sigla para Hyper text markup language. O HTML te permite configurar a estrutura f√≠sica da sua p√°gina web. Cada tag do HTML descreve um elemento espec√≠fico do documento, como podemos ver abaixo:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <header>
    <h1>Minha p√°gina Web!</h1>
  </header>
  <p>Bem vindos! Essa √© a estrutura b√°sica da minha primeira p√°gina</p>
  <ul>O que estou aprendendo:
    <li>Git & GitHub</li>
    <li>Internet</li>
    <li>Shell</li>
  </ul>
</body>
</html>

O conte√∫do dentro de <h1><h1> descreve o t√≠tulo principal (heading). N√≠veis diferentes de t√≠tulo s√£o descritos por <h2>, <h3> e assim por diante;
O conte√∫do dentro de uma tag <p> descreve um par√°grafo;
O conte√∫do dentro de uma tag <ul> descreve uma lista n√£o ordenada (unordered list), e cada item da lista est√° contido na tag <li>;
H√° v√°rios tipos de tags para descrever elementos diferentes da sua p√°gina web, como listas, imagens, links para navega√ß√£o, bot√µes...mas n√£o se preocupe! Voc√™ ir√° utiliz√°-los com muita frequ√™ncia, e a flu√™ncia vir√° com a pr√°tica.
A apar√™ncia da p√°gina √© definida por uma outra linguagem chamada CSS, que significa Cascading Style Sheets. O CSS √© uma linguagem que te permite descrever como os elementos definidos pelo HTML devem ser estilizados. O CSS te permite alterar a fonte, a cor, o tamanho e at√© mesmo incluir recursos como anima√ß√µes e √°udio. Voc√™ pode adicionar um estilo para a sua p√°gina como no exemplo:
Copiar
body {
  background-color: blue;
}

h1 {
  color: purple;
  font-size: large;
}

p {
  color: green;
  font-weight: bold;
}

h2 {
  color: red;
  border: 3px solid black;
}

As intera√ß√µes com a pessoa usu√°ria s√£o definidas por uma terceira linguagem: o JavaScript. √â o JavaScript que confere √† p√°gina um comportamento din√¢mico. Imagine que voc√™ esteja em uma p√°gina de e-commerce. Voc√™ pode clicar nos itens que quer comprar e salv√°-los em um carrinho, voc√™ pode adicionar filtros √†s suas buscas, navegar entre as sess√µes do site, tudo isso gra√ßas ao Javascript! Voc√™ deve estar se perguntando: Beleza, eu consigo visualizar tudo o que est√° acontecendo no momento que fa√ßo as compras na loja online. Mas para onde vai o meu pedido no momento em que efetuo o pagamento? O que acontece nos bastidores de um e-commerce?
Copiar
// Adiciona informa√ß√µes com um click
const sendButton = document.querySelector('.send-button');
sendButton.addEventListener('click', function () {
  return saveInformation(myInformations);
});
O seu pedido √© enviado como uma requisi√ß√£o para um servidor, que ir√° armazenar, processar e encaminhar as suas compras.
O servidor em uma aplica√ß√£o Web √© quem recebe as requisi√ß√µes do cliente. Lembra-se do protocolo HTTP? Pois bem, √© aqui que ele entra em cena. √â esse protocolo que define uma linguagem para que clientes e servidores se comuniquem. O servidor espera por requisi√ß√µes HTTP de uma porta espec√≠fica, sempre associada a um endere√ßo IP. Com as requisi√ß√µes, ele vai realizar a√ß√µes e enviar a resposta via HTTP. Todos os dados que viajam entre o cliente e o servidor s√£o enviados atrav√©s da rede Internet usando o protocolo TCP/IP.
E por fim, o banco de dados de uma aplica√ß√£o web √© onde a informa√ß√£o √© armazenada de forma acess√≠vel, gerenci√°vel e em constante atualiza√ß√£o. Imagine que voc√™ est√° lan√ßando uma nova rede social, que em cinco anos contar√° com 500 milh√µes de usu√°rios ativos no mundo todo. Voc√™ certamente ir√° precisar usar um banco de dados para armazenar informa√ß√µes sobre usu√°rios, posts, coment√°rios. E quando um visitante fizer uma requisi√ß√£o para acessar a p√°gina, as informa√ß√µes que ser√£o retornadas para a p√°gina vir√£o de um banco de dados. Assim, intera√ß√µes em tempo real, como vemos hoje no Instagram e Facebook, ser√£o vi√°veis.
Passamos pelos conceitos chaves de uma aplica√ß√£o Web, e vimos de forma simplificada o seu funcionamento. Mas a medida que a aplica√ß√£o cresce, como um √∫nico servidor conseguir√° lidar com milhares - ou at√© mesmo milh√µes! - de requisi√ß√µes de usu√°rios em tempo real?
Agora, vamos entender como escalonar uma aplica√ß√£o web. Uma forma para lidarmos com um grande volume de dados √© distribuir o tr√°fego de informa√ß√µes entre servidores no backend. O respons√°vel por gerenciar o tr√¢nsito de informa√ß√µes de uma aplica√ß√£o entre v√°rios servidores backend √© o que chamamos de balanceador de carga.
"Balanceamento de carga" √© um termo gen√©rico para uma s√©rie de algoritmos que distribuem as requisi√ß√µes para o servidor. Caso voc√™ tenha curiosidade em conhecer alguns desses algoritmos, pesquise por dois que s√£o muito populares no design de sistemas distribu√≠dos: Round Robin e Least Connections. Resumidamente, atrav√©s de algoritmos o balanceador de cargas divide para qual host as requisi√ß√µes ser√£o direcionadas em um sistema de servi√ßos distribu√≠dos.

Balanceador de carga.
Tudo tranquilo at√© aqui, certo?! O balanceador de cargas resolve o problema de tr√°fego de dados distribuindo as requisi√ß√µes para servidores backend. Mas replicar esse modelo ainda pode gerar problemas a medida que a sua aplica√ß√£o cresce. √Ä medida que adicionamos mais funcionalidades para a aplica√ß√£o, sua complexidade √© aumentada e a carga de trabalho solicitada ao servidor tamb√©m cresce, este conjunto de fatores pode sobrecarrega-lo. Assim, para resolver esse problema, √© necess√°rio separar o servidor por funcionalidade. √â aqui que servi√ßos entra em a√ß√£o.
Um servi√ßo √© apenas outro servidor capaz de interagir com servidores, o que n√£o acontece com um servidor Web, que interage apenas com o cliente. Cada servi√ßo tem uma funcionalidade, como um servi√ßo para autentica√ß√£o de usu√°rio ou servi√ßos de busca. Assim, √© poss√≠vel quebrar o servidor Web da sua aplica√ß√£o em m√∫ltiplos servi√ßos, cada um com uma funcionalidade espec√≠fica. A grande vantagem dos servi√ßos √© que voc√™ pode escalon√°-los de forma independente. Al√©m disso, os times de uma empresa tamb√©m podem trabalhar de forma independente em um determinado servi√ßo, ao inv√©s de ter uma equipe numerosa trabalhando em um √∫nico servidor, o que poderia se tornar um grande problema de gest√£o de projeto.
Tudo o que vimos at√© agora funciona muito bem para escalonar o tr√°fego de dados. Mas a sua aplica√ß√£o ainda est√° centralizada em um √∫nico lugar. Quando usu√°rios do mundo todo come√ßarem a acessar o seu site, eles podem ter um tempo de resposta maior devido √† grande dist√¢ncia entre cliente e servidor. Uma forma de resolvermos esse problema √© usando o que chamamos de Rede de Distribui√ß√£o de Conte√∫do, ou Content Delivery Network (CDN). O CDN √© um sistema de distribui√ß√£o de servidores "proxy". Podemos entender um servidor proxy como sendo um intermedi√°rio entre cliente e servidor.
Empresas com uma grande quantidade de tr√°fego distribu√≠do no mundo todo podem pagar por companhias que oferecem servi√ßos de CDN. Assim, usu√°rios de diversas localidades poder√£o acessar a aplica√ß√£o com um tempo de resposta menor. Um exemplo √© a Akamai, que tem sedes em pontos estrat√©gicos no mundo todo para garantir uma melhor experi√™ncia ao usu√°rio. Se o conte√∫do da sua aplica√ß√£o Web n√£o precisa cruzar o oceano para que um usu√°rio na China possa utiliz√°-lo, o tempo de resposta √© muito menor. A Akamai, por exemplo, consegue reduzir esse tempo de lat√™ncia ao armazenar c√≥pias do conte√∫do da aplica√ß√£o (arquivos como o HTML, CSS, m√≠dia) do servidor dos seus clientes. Assim, a Akamai consegue fornecer a aplica√ß√£o para o usu√°rio de seus clientes sem precisar ter acesso ao seu servidor de quem a contratou.
Vamos fixar o que aprendemos? Responda ao Quiz para verificar sua compreens√£o do texto:
Quiz - O modelo Cliente & Servidor e a estrutura de uma aplica√ß√£o web


////Como vimos no v√≠deo acima, o funcionamento da Internet depende de regras, que s√£o os protocolos. √â atrav√©s desses protocolos que conseguimos acessar p√°ginas, fazer downloads, enviar emails. Dentre os protocolos, h√° dois que s√£o frequentemente utilizados: o protocolo TCP/IP e o protocolo HTTP.
O Protocolo TCP/IP, como vimos, √© a base de envio e recebimento de dados de toda a Internet. √â um conjunto de regras que permite a comunica√ß√£o entre todas as m√°quinas conectadas √† Internet.
Vamos nos aprofundar um pouco mais sobre o que √© o protocolo HTTP, quais seus principais verbos e o que significa ser RESTful?
Voc√™ j√° aprendeu que, no modelo Cliente-Servidor, a troca de mensagens acontece atrav√©s de requisi√ß√µes e respostas: o Cliente envia uma requisi√ß√£o ao Servidor, que ir√° lhe retornar uma resposta. Com o grande volume de dados envolvidos nessa opera√ß√£o, gerenciar essas mensagens n√£o √© uma tarefa f√°cil. Assim, Cliente e Servidor aderem a uma linguagem comum, com regras que alinham as expectativas de ambas as partes, de forma que eles sabem exatamente o que esperar. Essa linguagem √© o que chamamos de protocolo HTTP.
Cada requisi√ß√£o e resposta trocada entre Cliente e Servidor √© uma √∫nica transa√ß√£o HTTP. O HTTP √© uma linguagem de texto, o que significa que as mensagens trocadas s√£o quantificadas em bits. Cada mensagem √© dividida em duas partes: o header e o body.
√â importante ter em mente que o HTTP por si s√≥ n√£o consegue transmitir dados. Ele ainda depende do protocolo TCP/IP para pegar as requisi√ß√µes e respostas entre duas m√°quinas. O HTTP √© uma camada de abstra√ß√£o que padroniza a forma com que os hosts se comunicam.
Uma requisi√ß√£o ou resposta HTTP pura n√£o √© encriptada, sendo vulner√°vel a v√°rios tipos de ataques. Por outro lado, HTTPS √© uma forma mais segura de comunica√ß√£o que utiliza a encripta√ß√£o. Para adicionar mais essa camada de seguran√ßa, o HTTPS utiliza um segundo mecanismo de seguran√ßa: o SSL. N√£o se preocupe em entender os detalhes e as diferen√ßas entre cada protocolo. Por hora, √© interessante saber que eles existem. Websites grandes com milhares de usu√°rios, como o Google e o Facebook, utilizam o protocolo HTTPS para manter as nossas senhas, informa√ß√µes pessoais e at√© mesmo detalhes de cart√£o de cr√©dito em seguran√ßa na rede.
Vamos fazer uma segunda busca para entender sobre o protocolo HTTP. No seu navegador, busque por https://github.com/. Clique com o bot√£o direito, selecione "Inspecionar" e procure por Network na barra superior. Navegue para o reposit√≥rio da Trybe na sua barra de navega√ß√£o com a janela de inspecionar aberta: https://github.com/betrybe/. Selecione o primeiro nome e a aba Headers. Voc√™ ver√° uma tela como a que √© mostrada abaixo:

Header.
HTTP Headers
Como vimos, o protocolo HTTP √© composto por Header e Body. O Header cont√©m metadata (dados sobre dados) que incluem o tipo de requisi√ß√£o (GET, POST, PUT, DELETE), o caminho URL, o endere√ßo IP dentre outros. Para a p√°gina que estamos usando como exemplo, na sess√£o Response Headers os mais importantes s√£o:
Content-Type: text/plain Especifica como os dados s√£o representados. Nesse exemplo, temos o texto sendo enviado como resposta no formato HTML.
Server: GitHub.com Servidor Web para onde as requisi√ß√µes est√£o sendo feitas.
Status: 200 OK Forma padr√£o para o servidor comunicar ao cliente sobre o resultado da requisi√ß√£o. O c√≥digo 200 significa que o servidor encontrou o recurso e est√° enviando o resultado da requisi√ß√£o.
Host: api.github.com Host da aplica√ß√£o
cookie: _octo=GH1.1.358825508.1593780201; _ga=GA1.2.60245099.1593780202; logged_in=yes; dotcom_user=isabellavjs; tz=America%2FSao_Paulo
Novamente, voc√™ n√£o precisa saber todos os pares de nome-valor. Saber onde encontr√°-los no seu navegador √© o suficiente para voc√™ come√ßar a explor√°-los conforme a sua necessidade.
HTTP Body
O servidor armazena ent√£o os dados (metadados) mais importantes para estabelecer uma comunica√ß√£o com o cliente. O Body refere-se ao corpo da mensagem que est√° sendo transmitida. Voc√™ pode acess√°-lo clicando em Response na barra superior. Para a requisi√ß√£o que fizemos, acessar a p√°gina https://github.com/, o body cont√©m o HTML para a p√°gina que estamos querendo acessar. Para praticar, experimente navegar nos outros arquivos que foram retornados para o navegador ap√≥s a requisi√ß√£o! Voc√™ pode acess√°-los no menu dispon√≠vel na barra lateral esquerda.

Body.
M√©todos HTTP
Os m√©todos HTTP s√£o os verbos que dizem ao servidor o que fazer com os dados no URL. Como vimos, o endere√ßo URL identifica recursos espec√≠ficos. Quando o cliente utiliza o endere√ßo URL combinado a um verbo HTTP, o servidor saber√° qual ser√° a a√ß√£o necess√°ria para cada recurso. Os exemplos mais comuns s√£o:
GET
O m√©todo GET √© o mais comum, e √© utilizado para ler informa√ß√µes encaminhadas pelo servidor para uma URL espec√≠fica. As requisi√ß√µes GET s√£o apenas para leitura, o que significa que os dados nunca poder√£o ser modificados no servidor. O servidor ir√° apenas retornar os dados, sem modific√°-los. Assim, esse tipo de requisi√ß√£o √© considerada uma opera√ß√£o segura, pois o efeito retornado ser√° sempre o mesmo, independentemente do n√∫mero de requisi√ß√µes feitas. Assim sendo, dizemos que requisi√ß√µes GET s√£o idempotentes, o que significa que o efeito da requisi√ß√£o no servidor ser√° sempre o mesmo - fazer milh√µes de requisi√ß√µes GET para o mesmo URL tem o mesmo efeito que uma √∫nica requisi√ß√£o. O m√©todo GET apenas retorna dados.
Requisi√ß√µes GET s√£o respondidas com status 200 (OK) se o recurso que estamos querendo acessar for encontrado com sucesso, ou 404 (NOT FOUND) se a p√°gina n√£o for encontrada.

404 - Page not found.
POST
O m√©todo POST √© utilizado para criar um novo recurso, como um formul√°rio para login. Voc√™ usar√° o m√©todo POST para criar um recurso subordinado (ex: novo usu√°rio) para a aplica√ß√£o pai (ex: http://exemplo.com/usuario). Ao contr√°rio do m√©todo GET, o m√©todo POST n√£o √© nem seguro e nem idempotente. Fazer duas ou mais requisi√ß√µes POSTS resultar√° em novos recursos criados (mesmo que id√™nticos). Requisi√ß√µes POST s√£o retornadas com o status code 201 (CREATED) e um novo caminho no header com o Link do recurso criado.
PUT
O m√©todo PUT √© utilizado para atualizar o recurso identificado pelo URL. Esse m√©todo tamb√©m pode ser utilizado para criar um novo recurso. Requisi√ß√µes PUT n√£o s√£o consideradas opera√ß√µes seguras, pois o estado da aplica√ß√£o √© modificado no servidor. No entanto, o m√©todo PUT √© idempotente porque m√∫ltiplas requisi√ß√µes PUT para atualizar um recurso t√™m o mesmo efeito que uma √∫nica requisi√ß√£o.
A resposta a requisi√ß√£o √© o status code 200 (OK) se o recurso foi atualizado com sucesso, ou 404 (NOT FOUND) se ele n√£o for encontrado.
DELETE
DELETE √© utilizado para deletar um recurso identificado pelo URL. As requisi√ß√µes DELETE s√£o idempotentes, pois quando deletamos um recurso ele ser√° deletado. Voc√™ pode fazer milhares de requisi√ß√µes com o m√©todo DELETE que no fim o resultado ser√° o mesmo: um recurso deletado.
A resposta requisi√ß√£o √© o status code 200 (OK) se o recurso for deletado com sucesso, ou 404 (NOT FOUND) se o recurso que ser√° deletado n√£o existir.
REST
Voc√™ pode j√° ter ouvido falar do termo RESTful para descrever uma aplica√ß√£o. REST √© a sigla para Representational State Transfer. √â um estilo de arquitetura utilizado no design de aplica√ß√µes Web. O estado da aplica√ß√£o s√£o os dados necess√°rios para que o servidor possa atender a uma determinada requisi√ß√£o. As regras do REST nos guiam a desenvolver sistemas mais perform√°ticos, escal√°veis, simples, de f√°cil manuten√ß√£o e modifica√ß√£o, port√°til e confi√°vel. Dentre elas, podemos destacar:
Interface uniforme: define a interface entre cliente e servidor de forma a desacoplar a arquitetura da aplica√ß√£o. Os verbos que vimos acima descrevem a grande maioria das regras para interface uniforme. Dentre as defini√ß√µes previstas pelo REST, as mais importantes s√£o:
Recursos, como dados de um banco de dados, devem ser identificados na requisi√ß√£o e o cliente ter√° acesso apenas a representa√ß√£o do recurso (ex: JSON, HTML)
O cliente deve ter informa√ß√µes suficientes para manipular recursos no servidor utilizando representa√ß√µes
As mensagens trocadas entre cliente e servidor devem ser auto-descritivas
Stateless: Essa regra define que todos os dados do estado da aplica√ß√£o que precisam ser manipulados em uma requisi√ß√£o devem estar contidos na pr√≥pria requisi√ß√£o (URL, HTTP body, HTTP header) e o servidor deve encaminhar para o cliente todos os dados referentes ao estado na resposta (HTTP headers, status code, HTTP response body).
O protocolo HTTP √© uma pe√ßa chave na comunica√ß√£o entre cliente-servidor. Para construir aplica√ß√µes RESTFul √© necess√°rio compreender o b√°sico de HTTP. Assim, voc√™ ser√° capaz de criar p√°ginas perform√°ticas e escal√°veis que far√£o a diferen√ßa na vida de muitos usu√°rios!
